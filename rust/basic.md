# rust

## 基础

整数 1、浮点数 1.2、字符 'a'、字符串 "abc"、布尔值 true 和单元类型 () 可以用数字、文字或符号之类的 “字面量”（literal）来表示。

另外，通过加前缀 0x、0o、0b，数字可以用十六进制、八进制或二进制记法表示。

为了改善可读性，可以在数值字面量中插入下划线，比如：1_000 等同于 1000，0.000_001 等同于 0.000001。

u32 后缀来表明字面量是一个 32 位无符号整数，i32 后缀表明字面量是一个 32 位有符号整数

## 栈

> 栈中的所有数据都必须占用已知且固定大小的内存空间

## 堆

> 对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

## 性能区别

> 在**栈上分配内存比在堆上分配内存要快**，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

## 无符号整数

- 只能表示非负整数，即从0到某个正整数的范围
- 例如：`u8`、`u16`、`u32`、`u64`、`u128` 等

```rust
//u8（8位无符号整数）：范围是0到255 8位指的是十进制的数字转为二进制之后，字符长度不可超过8
let a: u8 = 100;
let b: u8 = 200;
```

## 有符号整数

- 能表示正数、负数和零，范围大约是对应无符号整数范围的一半对称分布在正负数上。
- 例如：`i8`、`i16`、`i32`、`i64`、`i128` 等。

```rust
let a: i8 = -100;
let b: i8 = 100;

```

## 符号

 1. i  有符号整数
 2. u  无符号整数
 3. f32 32位单精度浮点数
 4. f64 64位双精度浮点数

## 字符串

```rust

let s = 'hello'
s = '12'

/* 
此时会报错，因为rust中变量是不可变的
但是字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，这种情况，字符串字面值就完全无用武之地。 为此，Rust 为我们提供动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。
*/

let s = String::from("hello");
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 在字符串后追加字面值

println!("{}", s); // 将打印 `hello, world!`

```

___

## 函数

```rust
// 死循环函数
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}

fn main() {  
    let x = 5; // x 是一个整数值  
    let y = &x; // y 是对 x 的引用  
  
    assert_eq!(5, x); // 确保 x 的值是 5  
    assert_eq!(5, *y); // 使用 * 运算符来解引用 y，并获取它所指向的值（即 x 的值）   & 引用的意思
}
```

## 所有权 important

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

``` javascript
 const fn = () => {
  const a = 1
  return a
 }
 
 let job = fn()
// 在js这个是闭包，其中的a不会被垃圾回收移除，因为被外部引用了，那么堆中一直会有个空间存储这个
```

```rust
 const fn = () => {
  const a = 1
  return a
 }
 
 let job = fn()
 // 但是在rust中，在堆中rust会被清除，然后其中a的所有权会被转移到job
```
