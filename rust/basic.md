# rust

## 基础

整数 1、浮点数 1.2、字符 'a'、字符串 "abc"、布尔值 true 和单元类型 () 可以用数字、文字或符号之类的 “字面量”（literal）来表示。

另外，通过加前缀 0x、0o、0b，数字可以用十六进制、八进制或二进制记法表示。

为了改善可读性，可以在数值字面量中插入下划线，比如：1_000 等同于 1000，0.000_001 等同于 0.000001。

u32 后缀来表明字面量是一个 32 位无符号整数，i32 后缀表明字面量是一个 32 位有符号整数

## 栈

> 栈中的所有数据都必须占用已知且固定大小的内存空间

## 堆

> 对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

## 性能区别

> 在**栈上分配内存比在堆上分配内存要快**，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

## 无符号整数

- 只能表示非负整数，即从0到某个正整数的范围
- 例如：`u8`、`u16`、`u32`、`u64`、`u128` 等

```rust
//u8（8位无符号整数）：范围是0到255 8位指的是十进制的数字转为二进制之后，字符长度不可超过8
let a: u8 = 100;
let b: u8 = 200;
```

## 有符号整数

- 能表示正数、负数和零，范围大约是对应无符号整数范围的一半对称分布在正负数上。
- 例如：`i8`、`i16`、`i32`、`i64`、`i128` 等。

```rust
let a: i8 = -100;
let b: i8 = 100;

```

## 符号

 1. i  有符号整数
 2. u  无符号整数
 3. f32 32位单精度浮点数
 4. f64 64位双精度浮点数

## 字符串

```rust

let s = 'hello'
s = '12'

/* 
此时会报错，因为rust中变量是不可变的
但是字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，这种情况，字符串字面值就完全无用武之地。 为此，Rust 为我们提供动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。
*/

let s = String::from("hello");
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 在字符串后追加字面值

println!("{}", s); // 将打印 `hello, world!`

```

___

## 函数

```rust
// 死循环函数
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}

fn main() {  
    let x = 5; // x 是一个整数值  
    let y = &x; // y 是对 x 的引用  
  
    assert_eq!(5, x); // 确保 x 的值是 5  
    assert_eq!(5, *y); // 使用 * 运算符来解引用 y，并获取它所指向的值（即 x 的值）   & 引用的意思
}
```

## 所有权 important

1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

``` javascript
 const fn = () => {
  const a = 1
  return a
 }
 
 let job = fn()
// 在js这个是闭包，其中的a不会被垃圾回收移除，因为被外部引用了，那么堆中一直会有个空间存储这个
```

```rust
 const fn = () => {
  const a = 1
  return a
 }
 
 let job = fn()
 // 但是在rust中，在堆中rust会被清除，然后其中a的所有权会被转移到job
```

## 字符含义

1. struct  定义数据结构的
2. impl 通过 impl 块，你可以为结构体定义方法，增强其功能和可用性。
3. self 类似js中的this
4. BOX<T> 是一种智能指针，它在堆上分配内存，并提供对该内存的所有权和访问。Box<T> 是最简单的智能指针类型，主要用于以下场景：

在堆上分配大数据：将数据存储在堆上而不是栈上。
转移所有权：将数据的所有权从一个作用域移动到另一个作用域。
递归类型：在定义递归数据结构时使用。


## 生命周期

>生命周期（lifetime）是这样一种概念，编译器（中的借用检查器）用它来保证所有的借用都是有效的。确切地说，一个变量的生命周期在它创建的时候开始，在它销毁的时候结束。虽然生命周期和作用域经常被一起提到，但它们并不相同。例如考虑这种情况，我们通过 & 来借用一个变量。该借用拥有一个生命周期，此生命周期由它声明的位置决定。于是，只要该借用在出借者（lender）被销毁前结束，借用就是有效的。然而，借用的作用域则是由使用引用的位置决定的。

``` rust
// 因为 'a可以代表任何生命周期，但是通常它的生命周期要比函数的局部作用域长。那么就会报错

// `print_refs` 接受两个 `i32` 的引用，它们有不同的生命周期 `'a` 和 `'b`。
// 这两个生命周期都必须至少要和 `print_refs` 函数一样长。
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// 不带参数的函数，不过有一个生命周期参数 `'a`。
fn failed_borrow<'a>() {
    let _x = 12;

    // 报错：`_x` 的生命周期不够长
    let y: &'a i32 = &_x;
    // 在函数内部使用生命周期 `'a` 作为显式类型标注将导致失败，因为 `&_x` 的
    // 生命周期比 `y` 的短。短生命周期不能强制转换成长生命周期。
}

fn main() {
    // 创建变量，稍后用于借用。
    let (four, nine) = (4, 9);

    // 两个变量的借用（`&`）都传进函数。
    print_refs(&four, &nine);
    // 任何被借用的输入量都必须比借用者生存得更长。
    // 也就是说，`four` 和 `nine` 的生命周期都必须比 `print_refs` 的长。

    failed_borrow();
    // `failed_borrow` 未包含引用，因此不要求 `'a` 长于函数的生命周期，
    // 但 `'a` 寿命确实更长。因为该生命周期从未被约束，所以默认为 `'static`。
}


```